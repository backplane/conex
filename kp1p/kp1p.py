#!/usr/bin/env python3
""" convert KeePassX-exported csv files into 1Password-importable csv files """
import argparse
import csv
import os
import stat
import sys
from typing import IO, Dict, Final, Iterable, List, Optional, Sequence

# input format
# Group,Title,Username,Password,URL,Notes
I_GROUP: Final = "Group"
I_TITLE: Final = "Title"
I_USERNAME: Final = "Username"
I_PASSWORD: Final = "Password"
I_URL: Final = "URL"
I_NOTES: Final = "Notes"
I_FIELDS: Final = (I_GROUP, I_TITLE, I_USERNAME, I_PASSWORD, I_URL, I_NOTES)

# output format
# title,website,username,password,notes,custom field 1,custom field 2,...
# see https://support.1password.com/import-mac/
O_TITLE: Final = "title"
O_WEBSITE: Final = "website"
O_USERNAME: Final = "username"
O_PASSWORD: Final = "password"
O_NOTES: Final = "notes"
O_GROUP: Final = "group"  # see args.include_group
O_FIELDS: Final = (O_TITLE, O_WEBSITE, O_USERNAME, O_PASSWORD, O_NOTES)


def warn(message: str):
    """write the given message to stderr"""
    print(message, file=sys.stderr, flush=True)


def read_csv(csvfh: IO) -> List[Dict[str, str]]:
    """
    read csv from the given file-like object, return a list of dict row records
    the file-like will not be closed
    """
    reader = csv.DictReader(csvfh, dialect=csv.unix_dialect)
    return list(reader)


def write_csv(
    csvfh: IO,
    rows: Iterable[Dict[str, Optional[str]]],
    fields: Sequence[str],
    extrasaction: str = "ignore",
    dialect=csv.excel,
):
    """
    write a csv file from the given list/iterables of dicts
    """
    writer = csv.DictWriter(
        csvfh,
        fields,
        extrasaction=extrasaction,
        dialect=dialect,
    )
    writer.writeheader()
    writer.writerows(rows)


def openx(filename: str, alt_handle: IO, *args, **kwargs) -> IO:
    """
    if the given filename is '-', immediately return the alternate handle;
    otherwise open the given filename using the given args/kwargs.
    this is useful for supporting stdin/stdout
    """
    if filename == "-":
        return alt_handle
    return open(filename, *args, **kwargs)  # pylint: disable=consider-using-with


def main() -> int:
    """
    entrypoint for direct execution
    returns an integer suitable for use by sys.exit (see the os.EX_* constants)
    """
    # first set a tight umask because we're dealing with sensitive data
    os.umask(stat.S_IXUSR | stat.S_IRWXG | stat.S_IRWXO)  # u-x,go-rwx

    argp = argparse.ArgumentParser(
        description=(
            "Utility for translating csv files exported from KeePassX into a "
            "csv format that is better supported by 1Password"
        ),
        epilog=(
            "WARNING: KEEPASSX'S CSV EXPORT FUNCTION ONLY INCLUDES A VERY "
            "LIMITED SUBSET OF YOUR DATA. THINGS LIKE YOUR TOTP SEEDS WILL BE "
            "MISSING FROM THE CSV FILE GENERATED BY KEEPASSX!"
        ),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    argp.add_argument(
        "infile",
        type=str,
        help="the KeePassX-created csv file to be read",
    )
    argp.add_argument(
        "-o",
        "--outfile",
        type=str,
        default="1p_import.csv",
        help="the filename of the 1Password-readable csv file to write",
    )
    argp.add_argument(
        "--overwrite",
        action="store_true",
        help="enable overwriting the outfile if it already exists",
    )
    argp.add_argument(
        "--include-group",
        action="store_true",
        help=(
            'enable including the "group" field in the output file, this is '
            'normally excluded because of the suboptimal way "custom fields" '
            "are handled by 1Password"
        ),
    )

    # process the arguments
    args = argp.parse_args()
    output_fields = O_FIELDS + (O_GROUP,) if args.include_group else O_FIELDS
    open_mode = "wt" if args.overwrite else "xt"

    # read in the csv data
    with openx(args.infile, sys.stdin, "rt", encoding="utf-8") as fhandle:
        input_rows = read_csv(fhandle)

    # prepare a converted version of the csv data
    # note: csv.writer converts None to an empty string
    # for more info, see: https://docs.python.org/3/library/csv.html#csv.writer
    output_rows = [
        {
            O_TITLE: row.get(I_TITLE, f"Imported Item #{rownum}"),
            O_WEBSITE: row.get(I_URL),
            O_USERNAME: row.get(I_USERNAME),
            O_PASSWORD: row.get(I_PASSWORD),
            O_NOTES: row.get(I_NOTES),
            O_GROUP: row.get(I_GROUP),
        }
        for rownum, row in enumerate(input_rows)
    ]
    if not output_rows:
        warn("fatal: no output entries to write")
        return os.EX_NOINPUT

    # write out the converted csv data
    try:
        with openx(args.outfile, sys.stdout, open_mode, encoding="utf-8") as fhandle:
            write_csv(fhandle, output_rows, output_fields)
    except FileExistsError:
        warn(f'fatal: the output file "{args.outfile}" already exists')
        return os.EX_CANTCREAT

    return 0


if __name__ == "__main__":
    sys.exit(main())
